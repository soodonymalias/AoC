<body>
<script src="/helpers/runner.js"></script>
<script>

const arrowcoords = {
  '^': [0,1],
  A: [0,2],
  '<': [1,0],
  v: [1,1],
  '>': [1,2]
};
  
const numpadcoords = {
  0: [3,1],
  A: [3,2],
  1: [2,0],
  2: [2,1],
  3: [2,2],
  4: [1,0],
  5: [1,1],
  6: [1,2],
  7: [0,0],
  8: [0,1],
  9: [0,2]
};


function pathsTo(curr, target, blocked) {
  let paths = new Set();
  let pathsInProgress = [];
  pathsInProgress.push({curr, path: []});
  while (pathsInProgress.length > 0) {
    let p = pathsInProgress.pop();
    if (p.curr[0] == blocked[0] && p.curr[1] == blocked[1])
      continue;
    if (p.curr[0] == target[0] && p.curr[1] == target[1]) {
      p.path.push("A");
      paths.add(p.path.join(""));
      continue;
    }
    let disti = p.curr[0] - target[0];
    let distj = p.curr[1] - target[1];
    if (disti > 0) {
      let newP = {};
      newP.curr = [p.curr[0]-1, p.curr[1]];
      newP.path = [...p.path];
      newP.path.push("^");
      pathsInProgress.push(newP);
    }
    if (disti < 0) {
      let newP = {};
      newP.curr = [p.curr[0]+1, p.curr[1]];
      newP.path = [...p.path];
      newP.path.push("v");
      pathsInProgress.push(newP);
    }
    if (distj > 0) {
      let newP = {};
      newP.curr = [p.curr[0], p.curr[1]-1];
      newP.path = [...p.path];
      newP.path.push("<");
      pathsInProgress.push(newP);
    }
    if (distj < 0) {
      let newP = {};
      newP.curr = [p.curr[0], p.curr[1]+1];
      newP.path = [...p.path];
      newP.path.push(">");
      pathsInProgress.push(newP);
    }
  }
  return paths;
}

function stepsFor(val, coords, fornum) {
  let steps = [];
  let curr = coords["A"];
  let paths = new Set();
  for (let i = 0; i < val.length; i++) {
    let next = coords[val[i]];
    let nextStepPaths = pathsTo(curr, next, fornum ? [3, 0] : [0,0]);
    let newPaths = new Set();
    if (paths.size == 0) {
      paths = nextStepPaths;
    } else {
      for (let p of paths) {
        for (let n of nextStepPaths) {
          newPaths.add(p.concat(n));
        }
      }
      paths = newPaths;
    }
    curr = next;
  }
  return paths;
}

let cache = new Map();
cache.set("^^>A", "<AAv>A^A"); // better
cache.set(">vA", "vA<A^>A"); // same
cache.set(">^A", "vA<^A>A"); // defaut, better

function shortestPath(val) {
  if (cache.has(val)) {
    return cache.get(val);
  }
  let paths = stepsFor(val, arrowcoords, false);
  let minLength = 100;
  let maxRepeats = -1;
  let best = null;
  for (let p of paths) {
    if (p.length > minLength)
      continue;
    if (p.length < minLength) {
      minLength = p.length;
      maxRepeats = -1;
    }
    let repeats = 0;
    for (let i = 1; i < p.length; i++) {
      if (p[i] == p[i-1])
        repeats++;
    }
    if (repeats == maxRepeats)
      console.log(val + " " + best + " " + p);
    if (repeats > maxRepeats) {
      maxRepeats = repeats;
      best = p;
    }
  }
  cache.set(val, best);
  return best;
}

function addToMap(map, p, val) {
  let i = 0;
  while (i < p.length) {
    let startI = i;
    while (p[i] != "A") {
      i++;
    }
    i++;
    let s = p.substring(startI, i);
    if (!map.has(s))
      map.set(s, val);
    else
      map.set(s, map.get(s) + val);
  }
}

function doNums(i) {
  let numpaths = stepsFor(i, numpadcoords, true);
  let paths = []
  for (let p of numpaths) {
    let map = new Map();
    addToMap(map, p, 1);
    paths.push(map);
  }
  return paths;
}

function doArrows(paths) {
  let newPaths = [];
  for (let p of paths) {
    let np = new Map();
    for (let s of p) {
      addToMap(np, shortestPath(s[0]), s[1]);
    }
    newPaths.push(np);
  }

  return newPaths;

  /*let minLength = Number.MAX_SAFE_INTEGER;
  for (let p of newPaths) {
    minLength = Math.min(minLength, p.length);
  }
  let outPaths = new Set();
  for (let p of newPaths) {
    if (p.length == minLength)
      outPaths.add(p);
  }
  return outPaths;*/
}

function run(inputs, steps) {
  let result = 0;
  for (let i of inputs) {
    let paths = doNums(i);
    //console.log(structuredClone(paths));
    for (let step = 0; step < steps; step++) {
      paths = doArrows(paths);
      //console.log(structuredClone(paths
      //console.log(step);
    }
    minLength = Number.MAX_SAFE_INTEGER;
    for (let p of paths) {
      let length = 0;
      for (let s of p) {
        length += s[0].length * s[1];
      }
      minLength = Math.min(minLength, length);
      //console.log(p);
    }
    //console.log(minLength);
    result += minLength * i.substring(0, i.length - 1);
  }
  console.log(cache);
  return result;
}

function part1(inputs) {
  return run(inputs, 2);
}

function part2(inputs) {
  // high: 260986506446672
  // correct test answers:
  // 029A: 82050061710
  // 980A: 72242026390
  // 179A: 81251039228
  // 456A: 80786362258
  // 379A: 77985628636
  // Total 154115708116294
  return run(inputs, 25);
}

</script>
</body>